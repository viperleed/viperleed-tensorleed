!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module rfactor ! in 
    interface  ! in :rfactor
        module r_factor_new ! in :rfactor:rfactor.f90
            subroutine r_factor_beam(y1,size_y1,y2,size_y2,e_start1,e_start2,e_step,v0r_shift,r_pendry,numerator,denominator,n_overlapping_points) ! in :rfactor:rfactor.f90:r_factor_new
                real dimension(size_y1),intent(in) :: y1
                integer, optional,intent(in),check(len(y1)>=size_y1),depend(y1) :: size_y1=len(y1)
                real dimension(size_y2),intent(in) :: y2
                integer, optional,intent(in),check(len(y2)>=size_y2),depend(y2) :: size_y2=len(y2)
                real intent(in) :: e_start1
                real intent(in) :: e_start2
                real intent(in) :: e_step
                real intent(in) :: v0r_shift
                real intent(out) :: r_pendry
                real intent(out) :: numerator
                real intent(out) :: denominator
                integer intent(out) :: n_overlapping_points
            end subroutine r_factor_beam
            subroutine rfactor_beamset(y1,sizes_y1,y2,sizes_y2,e_start1,e_start2,nr_beams,e_step,v0rshift,r_pe_weighted,r_pe_beams,n_overlapping_points) ! in :rfactor:rfactor.f90:r_factor_new
                real dimension(:,:),intent(in) :: y1
                integer dimension(nr_beams),intent(in),depend(nr_beams) :: sizes_y1
                real dimension(:,:),intent(in) :: y2
                integer dimension(nr_beams),intent(in),depend(nr_beams) :: sizes_y2
                real dimension(nr_beams),intent(in) :: e_start1
                real dimension(nr_beams),intent(in),depend(nr_beams) :: e_start2
                integer, hidden,optional,intent(in),check(len(e_start1)==len(e_start2)),depend(e_start1,e_start2) :: nr_beams=len(e_start1)
                real intent(in) :: e_step
                real intent(in) :: v0rshift
                real intent(out) :: r_pe_weighted
                real dimension(nr_beams),intent(out),depend(nr_beams) :: r_pe_beams
                integer dimension(nr_beams),intent(out),depend(nr_beams) :: n_overlapping_points
            end subroutine rfactor_beamset
            subroutine rfactor_beamtypes(y1,sizes_y1,y2,sizes_y2,e_start1,e_start2,nr_beams,e_step,v0rshift,beamtypes,nr_beamtypes,r_pe_weighted,r_pe_beams,n_overlapping_points) ! in :rfactor:rfactor.f90:r_factor_new
                real dimension(:,:),intent(in) :: y1
                integer dimension(nr_beams),intent(in),depend(nr_beams) :: sizes_y1
                real dimension(:,:),intent(in) :: y2
                integer dimension(nr_beams),intent(in),depend(nr_beams) :: sizes_y2
                real dimension(nr_beams),intent(in) :: e_start1
                real dimension(nr_beams),intent(in),depend(nr_beams) :: e_start2
                integer, hidden,optional,intent(in),check(len(e_start1)==len(e_start2)),depend(e_start1,e_start2) :: nr_beams=len(e_start1)
                real intent(in) :: e_step
                real intent(in) :: v0rshift
                integer dimension(nr_beams),intent(in),depend(nr_beams) :: beamtypes
                integer intent(in) :: nr_beamtypes
                real dimension(nr_beamtypes),intent(out),depend(nr_beamtypes) :: r_pe_weighted
                real dimension(nr_beams),intent(out),depend(nr_beams) :: r_pe_beams
                integer dimension(:),intent(out) :: n_overlapping_points
            end subroutine rfactor_beamtypes
            subroutine rfactor_v0ropt(opt_type,min_steps,max_steps,nr_used_v0) ! in :rfactor:rfactor.f90:r_factor_new
                integer intent(in) :: opt_type
                integer intent(in) :: min_steps
                integer intent(in) :: max_steps
                integer intent(out) :: nr_used_v0
            end subroutine rfactor_v0ropt
            subroutine prepare_beams(intensity,n_beams,ne_in,e_min,e_step,ne_beams,averaging_scheme,smoothing,ne_after,e_min_after,e_step_after) ! in :rfactor:rfactor.f90:r_factor_new
                real dimension(ne_in,n_beams),intent(in) :: intensity
                integer, optional,intent(in),check(shape(intensity,1)==n_beams),depend(intensity) :: n_beams=shape(intensity,1)
                integer, optional,intent(in),check(shape(intensity,0)==ne_in),depend(intensity) :: ne_in=shape(intensity,0)
                real dimension(n_beams),intent(in),depend(n_beams) :: e_min
                real dimension(n_beams),intent(in),depend(n_beams) :: e_step
                real dimension(n_beams),intent(in),depend(n_beams) :: ne_beams
                integer dimension(n_beams),intent(in),depend(n_beams) :: averaging_scheme
                integer intent(in) :: smoothing
                integer intent(in) :: ne_after
                real intent(in) :: e_min_after
                real intent(in) :: e_step_after
            end subroutine prepare_beams
            subroutine range_index_from_energy(e_min_current,ne_in,e_step,e_min_cut,e_max_cut,new_start_stop_step) ! in :rfactor:rfactor.f90:r_factor_new
                real intent(in) :: e_min_current
                integer intent(in) :: ne_in
                real intent(in) :: e_step
                real intent(in) :: e_min_cut
                real intent(in) :: e_max_cut
                integer dimension(3),intent(out) :: new_start_stop_step
            end subroutine range_index_from_energy
            subroutine limit_range_index(in_beams,n_beams,n_energies,e_min_current,e_step,beam_starts,ne_beams,ne_out_start,ne_out_stop,out_beams,new_ne,new_ne_beams,new_start_id) ! in :rfactor:rfactor.f90:r_factor_new
                real dimension(n_energies,n_beams),intent(in) :: in_beams
                integer, optional,intent(in),check(shape(in_beams,1)==n_beams),depend(in_beams) :: n_beams=shape(in_beams,1)
                integer, optional,intent(in),check(shape(in_beams,0)==n_energies),depend(in_beams) :: n_energies=shape(in_beams,0)
                real intent(in) :: e_min_current
                real intent(in) :: e_step
                integer dimension(n_beams),intent(in),depend(n_beams) :: beam_starts
                integer dimension(n_beams),intent(in),depend(n_beams) :: ne_beams
                integer intent(in) :: ne_out_start
                integer intent(in) :: ne_out_stop
                real dimension(ne_out_stop-ne_out_start+1,n_beams),intent(out),depend(ne_out_start,ne_out_stop,n_beams) :: out_beams
                integer intent(out) :: new_ne
                integer dimension(n_beams),intent(out),depend(n_beams) :: new_ne_beams
                real dimension(n_beams),depend(n_beams) :: new_start_id
            end subroutine limit_range_index
            subroutine derivative(data_in,dx,deriv,n_data) ! in :rfactor:rfactor.f90:r_factor_new
                real(kind=8) dimension(n_data),intent(in) :: data_in
                real(kind=8), optional,intent(in) :: dx=1.0
                real(kind=8), optional,dimension(n_data),intent(in,out),depend(n_data) :: deriv
                integer, optional,intent(in),check(len(data_in)>=n_data),depend(data_in) :: n_data=len(data_in)
            end subroutine derivative
            subroutine pendry_y(intensity,de,v0i,i_prime,y_func,n_data) ! in :rfactor:rfactor.f90:r_factor_new
                real(kind=8) dimension(n_data),intent(in) :: intensity
                real(kind=8), optional,intent(in) :: de=1.0
                real(kind=8), optional,intent(in) :: v0i=5.0
                real(kind=8) dimension(n_data),intent(hide),depend(n_data) :: i_prime
                real(kind=8), optional,dimension(n_data),intent(in,out),depend(n_data) :: y_func
                integer, optional,intent(in),check(len(intensity)>=n_data),depend(intensity) :: n_data=len(intensity)
            end subroutine pendry_y
            function parabolic_optimize(values) result (minimum_pair) ! in :rfactor:rfactor.f90:r_factor_new
                real dimension(:),intent(in) :: values
                real dimension(2) :: minimum_pair
            end function parabolic_optimize
            function trapez_integration_const_dx(f,dx) result (integral) ! in :rfactor:rfactor.f90:r_factor_new
                real dimension(:),intent(in) :: f
                real intent(in) :: dx
                real :: integral
            end function trapez_integration_const_dx
            function test_exec(input) result (output) ! in :rfactor:rfactor.f90:r_factor_new
                real intent(in) :: input
                real :: output
            end function test_exec
        end module r_factor_new
    end interface 
end python module rfactor

! This file was auto-generated with f2py (version:2).
! See http://cens.ioc.ee/projects/f2py2e/
